<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Identity.html">Identity</a><ul class='methods'><li data-type='method'><a href="Identity.html#enableVarnishCookie">enableVarnishCookie</a></li><li data-type='method'><a href="Identity.html#hasSession">hasSession</a></li><li data-type='method'><a href="Identity.html#isLoggedIn">isLoggedIn</a></li><li data-type='method'><a href="Identity.html#isConnected">isConnected</a></li><li data-type='method'><a href="Identity.html#getUser">getUser</a></li><li data-type='method'><a href="Identity.html#getUserId">getUserId</a></li><li data-type='method'><a href="Identity.html#getUserUuid">getUserUuid</a></li><li data-type='method'><a href="Identity.html#getUserContextData">getUserContextData</a></li><li data-type='method'><a href="Identity.html#getSpId">getSpId</a></li><li data-type='method'><a href="Identity.html#login">login</a></li><li data-type='method'><a href="Identity.html#logout">logout</a></li><li data-type='method'><a href="Identity.html#loginUrl">loginUrl</a></li><li data-type='method'><a href="Identity.html#logoutUrl">logoutUrl</a></li><li data-type='method'><a href="Identity.html#accountUrl">accountUrl</a></li><li data-type='method'><a href="Identity.html#phonesUrl">phonesUrl</a></li><li data-type='method'><a href="Identity.html#authFlowUrl">authFlowUrl</a></li><li data-type='method'><a href="Identity.html#signupFlowUrl">signupFlowUrl</a></li><li data-type='method'><a href="Identity.html#signinFlowUrl">signinFlowUrl</a></li><li data-type='method'><a href="Identity.html#showItpModalUponReturning">showItpModalUponReturning</a></li><li data-type='method'><a href="Identity.html#suppressItpModal">suppressItpModal</a></li><li data-type='method'><a href="Identity.html#showSimplifiedLoginWidget">showSimplifiedLoginWidget</a></li></ul></li><li><a href="Monetization.html">Monetization</a><ul class='methods'><li data-type='method'><a href="Monetization.html#hasProduct">hasProduct</a></li><li data-type='method'><a href="Monetization.html#hasSubscription">hasSubscription</a></li><li data-type='method'><a href="Monetization.html#hasAccess">hasAccess</a></li><li data-type='method'><a href="Monetization.html#subscriptionsUrl">subscriptionsUrl</a></li><li data-type='method'><a href="Monetization.html#productsUrl">productsUrl</a></li></ul></li><li><a href="Payment.html">Payment</a><ul class='methods'><li data-type='method'><a href="Payment.html#payWithPaylink">payWithPaylink</a></li><li data-type='method'><a href="Payment.html#purchaseHistoryUrl">purchaseHistoryUrl</a></li><li data-type='method'><a href="Payment.html#redeemUrl">redeemUrl</a></li><li data-type='method'><a href="Payment.html#purchasePaylinkUrl">purchasePaylinkUrl</a></li><li data-type='method'><a href="Payment.html#purchaseProductFlowUrl">purchaseProductFlowUrl</a></li><li data-type='method'><a href="Payment.html#purchaseCampaignFlowUrl">purchaseCampaignFlowUrl</a></li><li data-type='method'><a href="Payment.html#purchasePromoCodeProductFlowUrl">purchasePromoCodeProductFlowUrl</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Identity.html#event:error">error</a></li><li><a href="Identity.html#event:login">login</a></li><li><a href="Identity.html#event:logout">logout</a></li><li><a href="Identity.html#event:userChange">userChange</a></li><li><a href="Identity.html#event:sessionChange">sessionChange</a></li><li><a href="Identity.html#event:notLoggedin">notLoggedin</a></li><li><a href="Identity.html#event:sessionInit">sessionInit</a></li><li><a href="Identity.html#event:statusChange">statusChange</a></li></ul>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><p><a href="https://github.com/schibsted/account-sdk-browser"><img src="https://www.schibsted.com/Global/LogoTypes/Logos%202014/SMG_Small_2014_RGB.png" alt="logo"></a></p>
<p><a href="https://travis-ci.org/schibsted/account-sdk-browser"><img src="https://travis-ci.org/schibsted/account-sdk-browser.svg?branch=master" alt="Build Status"></a>
<a href="https://codecov.io/gh/schibsted/account-sdk-browser"><img src="https://codecov.io/gh/schibsted/account-sdk-browser/branch/master/graph/badge.svg" alt="Code coverage"></a>
<a href="https://snyk.io/test/github/schibsted/account-sdk-browser"><img src="https://snyk.io/test/github/schibsted/account-sdk-browser/badge.svg?targetFile=package.json" alt="Snyk"></a></p>
<h1>Schibsted account SDK for browsers</h1>
<p>Welcome! This is the home of the Schibsted account JavaScript SDK for use by any website that wishes
to use Schibsted account to sign up and log in users. Use it to generate URLs for your site's &quot;Log
in&quot; button, query the logged-in status of your users, and to check whether they have access to
products and subscriptions, etc.</p>
<p><a name="getting-started"></a></p>
<h2>Getting started</h2>
<ol>
<li>Do <code>npm install --save @schibsted/account-sdk-browser</code></li>
<li>Use this library as you would any other npm module: <code>import { Identity, Monetization, Payment } from '@schibsted/account-sdk-browser'</code>
<ol>
<li>If you use the CommonJS <code>require</code> syntax and you both want to reduce the size of your
JavaScript bundle <strong>and</strong> don't need all of Identity, Monetization and Payment modules from
this SDK — it's possible to <code>require('@schibsted/account-sdk-browser/identity')</code> (note the
<code>/identity</code> at the end) or <code>/monetization'</code> or <code>/payment'</code></li>
</ol>
</li>
<li>Build your site as you prefer. This library uses modern JavaScript syntax (including async/await
and other ES2017 and WHATWG features) by default. We recommend that you do any transpilation
yourself for the browser versions you need to cater to. See <a href="#polyfills-yo">this paragraph</a> for
info about our babelified version and info about polyfills.</li>
</ol>
<p><a name="upgrading-from-2.x"></a></p>
<h2>Upgrading from 2.x</h2>
<p>If you already use the 2.x branch of the Schibsted account JS SDK, certain changes will be required
to use this version of the SDK. We have chosen what we believe to be a middle ground between
&quot;remembering the work done in the old SDK&quot; and &quot;starting fresh&quot;. Therefore it is recommended that
you read this document in full. But ok, let's present some highlighted differences:</p>
<p><a name="differences-from-2.x"></a></p>
<h4>Differences from 2.x</h4>
<ul>
<li>Instead of using <code>SPiD.init()</code> for initialization, the new SDK exports three classes; <code>Identity</code>,
<code>Monetization</code> and <code>Payment</code></li>
<li>Many features (like logging in) requires a <code>redirectUri</code> parameter — both in the 2.x and 3.x
versions of the SDK. An important difference in the new version of our backends, is that we strive
to be more compliant with OpenID Connect standards. This means that redirect uris need to match
<strong>exactly</strong> (that is — including the query string). This will be a breaking change for some
people, because in the 2.x world, a redirect uri might look like <code>https://site.com</code> in self
service, and a login attempt with <code>redirectUri=https://site.com?article=1234</code> would then be ok
because it would only match on domain+path — but not query string. However — this will <strong>not</strong>
work in the 3.x world. OpenID Connect <strong>does</strong> have a suggestion for how to handle these
situations though, which is a parameter called <code>state</code> that you send in addition to the
<code>redirectUri</code>. See <a href="#regarding-state">this paragraph</a> for more information</li>
<li>The <code>'SPiD.'</code> string is removed from the name of all SDK events. So the event that used to be
<code>'SPiD.login'</code> is now just <code>'login'</code></li>
<li>You don't log in by setting <code>window.location</code>. Instead, you use the <code>login()</code> method on an
instance of <code>Identity</code></li>
<li>The JavaScript code in this browser SDK does <strong>NOT</strong> set any <code>document.cookie = ...</code> by default.
There is a function <code>enableVarnishCookie</code> that you can call on an <code>Identity</code> instance. This will
enable setting the <code>SP_ID</code> cookie whenever <code>hasSession()</code> is called (though most browsers require
that you are on a &quot;real domain&quot; for this to work — so, <strong>not</strong> <code>localhost</code>). Any other cookie
that you need set, you will have to set yourself</li>
<li>All functions that used to take callback functions in the 2.x version of the SDK don't do that
anymore. The new SDK instead uses promises where it makes sense (often written as <code>async</code>
functions). For example <code>Identity.getUser()</code> returns a promise. So, for instance if you used to do
this in v2.x:<pre class="prettyprint source lang-javascript"><code>identity.hasSession((err, data) => {
    if (err) {
        console.log('Nooo!', err)
    } else {
        console.log('Yay', data)
    }
});
</code></pre>
Now you should instead do:<pre class="prettyprint source lang-javascript"><code>// Either
identity.hasSession()
    .then(data => console.log('Yay', data))
    .catch(err => console.log('Nooo!', err));
// ... or if you're using async functions
try {
    const data = await identity.hasSession();
    console.log('Yay', data);
} catch (err) {
    console.log('Nooo!', err);
}
</code></pre>
</li>
<li>Listening to events is still supported, although since many functions return Promises, we expect
many users will find the use of Promise results preferable. But for those that prefer the events,
it works using a function <code>.on</code> that's compatible with Node's <code>EventEmitter</code>. For example
<code>SPiD.event.subscribe('SPiD.login', handler)</code> from 2.x becomes <code>Identity.on('login', handler)</code>.
Also, the functions <code>.off</code> and <code>.once</code> are supported</li>
<li>SPiD URI is gone. There are a handful of <code>***Url()</code> functions in each of the <code>Identity</code>,
<code>Monetization</code> and <code>Payment</code> classes for the relevant flows</li>
<li>The new SDK has inline jsdoc documentation that's available
<a href="https://schibsted.github.io/account-sdk-browser/">here</a> instead of tech docs.
These documents will always be up to date with the latest release so make sure to run <code>npm outdated</code> in your project to be notified about any new releases</li>
<li>The new UI flows are different than the old ones in that they use the Schibsted account API
endpoints just like any other client. For most clients this means absolutely nothing at all, but
for some, it's quite important; If you have ever asked our support staff to disable certain API
endpoint accesses, there is a chance that you'll encounter problems. For instance, if you've set
<code>NO ACCESS</code> on the <code>POST /signup</code> endpoint, <strong>users will not be able to sign up to your site</strong>
using the new flows</li>
<li>If you use our session-service, there are certain changes in the response from the session endpoint.
<ul>
<li>The <code>userStatus</code> field makes no sense in the session-service world, since it operates &quot;per-site&quot;
(there is one id.site.example domain for each site, so being logged in and connected for that
site means the same thing. Also, there is the <code>Identity.isConnected</code> function that's still kept
in case people prefer to keep the same logic with and without the session-service).</li>
<li>The <code>id</code> field (the one returning a MongoDb identifier like <code>abcdef0123456789abcdd00d</code>) has
finally been removed. It's been deprecated for a long time. The numeric <code>userId</code> (legacy) and
<code>uuid</code> fields are still present.</li>
</ul>
</li>
</ul>
<p><a name="polyfills-yo"></a></p>
<h4>Polyfills required for older browsers</h4>
<p>This SDK uses modern JavaScript features. If you support older browsers, you should use a tool like
babel to transform the JavaScript as needed. However — since certain teams have deployment pipelines
where it's difficult to do their own transpilation, we do provide some opt-in es5 files as well:</p>
<ol>
<li><code>@schibsted/account-sdk-browser/es5</code>: Include both <code>Identity</code>, <code>Monetization</code> and <code>Payment</code>.</li>
<li><code>@schibsted/account-sdk-browser/es5/global</code>: Include both <code>Identity</code>, <code>Monetization</code> and
<code>Payment</code>. In addition, add them as variables to the global <code>window</code> object.</li>
<li><code>@schibsted/account-sdk-browser/es5/identity</code>, <code>@schibsted/account-sdk-browser/es5/monetization</code>
or <code>@schibsted/account-sdk-browser/es5/payment</code> can be used to only include each class by itself.</li>
</ol>
<p>But then regardless of whether you use the es5 versions or not, you might need to polyfill certain
things that might be missing in the browsers you wish to support. A quick test using IE11 showed
that we needed polyfills for <code>Promise</code>, <code>URL</code>, <code>Object.entries</code>, <code>fetch</code>, <code>Number.isFinite</code> and
<code>Number.isInteger</code>. If you want any sort of debugging to work (say, if you're passing a function
using <code>console.log</code> as a parameter to any SDK function that supports logging), you might also need
to polyfill <code>console</code> and <code>console.log</code> (yeah, it's baffling, but a <a href="https://stackoverflow.com/questions/22315167/in-ie11-how-to-use-console-log">known
issue</a> in IE). We added
them from polyfill.io like this:</p>
<pre><code>&lt;script src=&quot;https://cdn.polyfill.io/v2/polyfill.js?features=Promise,URL,Object.entries,fetch,Number.isFinite,Number.isInteger,console,console.log&quot;&gt;&lt;/script&gt;
</code></pre>
<p><a name="itp-yo"></a></p>
<h2>Notes on Apple Intelligent Tracking Prevention (ITP)</h2>
<h4>or.. how I learned to stop worrying and ❤️ the Schibsted account session service</h4>
<p>Right, as of Safari 12, we can't rely on making requests from a site domain to the Schibsted account
domain. Safari 12 will possibly partition cookies in such requests in an attempt to protect the
user's privacy. While this is good for end-users, it presented a real problem for Schibsted account,
since our technique for deciding whether a user is logged in, is to send a request in precisely this
manner.</p>
<p>There are two ways to deal with this in Safari:</p>
<ol>
<li>You can continue with 3rd party requests, but this requires an iframe on that 3rd party domain
and it also requires user input in said iframe</li>
<li>You can re-design the system to not use 3rd party requests anymore</li>
</ol>
<p>We've tried to support both. For the 1st strategy, simply continue using the SDK like before. Be
sure to call <code>Identity.login</code> when authenticating, and <code>Identity.hasSession</code> when coming back to
your site from Schibsted account. This should pop up our so-called &quot;ITP Dialog&quot;. This is the iframe
mentioned in point 1 above, and clicking the Continue button in that frame will ensure the
<code>hasSession</code> call running inside the iframe is successful. The benefit of this strategy is it
requires very little work from you. The drawback is that every time you come back from
authentication, the user will have to see this &quot;ITP dialog&quot;.</p>
<p>So to work with strategy 2, we have re-designed our platform and introduced what we call the
session-service. If your site lives on site.example, you should assign a sub-domain for use with the
session-service (we propose id.site.example for production and id-pre.site.example for staging —
talk to our Customer Success team regarding how to get this set up). The goal is to have
https://id.site.example be a DNS name resolving to our session-service, since this enables us to
place a cookie on that domain that indicates that the user is logged in.</p>
<p>When the domain is set up, your client needs to be modified by our Customer Success team to enable
using this feature (this is done by them setting <code>session_service_domain = https://id.site.example</code>
in SysAdmin).</p>
<p>Finally, and this is where you, the user of account-sdk-browser need a change; When creating an
instance of <code>Identity</code> or <code>Monetization</code>, include the property <code>sessionDomain: 'https://id.site.example</code> in the constructor'.</p>
<p>So to sum up:</p>
<ol>
<li>Prepare a subdomain id.site.example (optionally id-pre.site.example for staging)</li>
<li>Enable the session-service for the client you use on your site</li>
<li>Add the <code>sessionDomain</code> property to the <code>Identity</code> or <code>Monetization</code> constructors</li>
</ol>
<p>1 and 2 requires communication with us, and 3 is done by you at a time of your choosing. The benefit
of this strategy is that we should never need to show any dialog or popup to the user, so it reduces
friction. The drawback is the work mentioned above.</p>
<p><a name="example-project"></a></p>
<h2>Simplified login widget</h2>
<p>Implementing this functionality requires that your brand uses session service. With this as a starting point, implementing simplified login in production is relatively straightforward:</p>
<ol>
<li>Ensure that your site has no site specific terms and conditions in the Schibsted account login flow.</li>
<li>Define rules for when and how often the simplified login prompt should be shown to unique users on your site. How you do this is up to you, but we recommend starting with showing the prompt once per user before potentially increasing this frequency over time.</li>
<li>Set up a function to check if users landing on your domain <a href="https://schibsted.github.io/account-sdk-browser/Identity.html#isLoggedIn">is logged in</a> to your site.</li>
<li>If the user is not logged-in to your site, call the <a href="https://schibsted.github.io/account-sdk-browser/Identity.html#showSimplifiedLoginWidget">showSimplifiedLoginWidget</a> function. The <code>showSimplifiedLoginWidget</code> accepts the same params as login function (<code>state</code> is required, it might be string or async function). If the simplified login prompt is to be loaded, <code>showSimplifiedLoginWidget</code> will return <code>true</code>.</li>
<li>Set up a way to store information about which users have been shown the simplified login prompt. How you do this is up to you, but one way is to use localStorage. Use this information to execute on the rules defined in #2.</li>
</ol>
<h2>Example project</h2>
<p>There is an example that demonstrates how the SDK can be used. The code is
<a href="https://github.com/schibsted/sdk-example">here</a>, and you can see it live
<a href="https://pro.sdk-example.com">here</a>. You have a use-case that we haven't thought of? Ask us to add
it by creating an <a href="https://github.com/schibsted/sdk-example/issues/new">issue</a>.</p>
<p>You can use that code as inspiration or just fork and play with it. The account-sdk-browser NPM
module is used for authenticating the user with Schibsted account. Take a look at how the SDK is
initialized.</p>
<p>When a user wants to log in to your site, you direct them to a UI flow that is hosted by Schibsted
Account. We authenticate the user and redirect them back to your site. This final redirect back to
your site is done in accordance with the OAuth2 spec. That means that we pass a <code>code</code> in the query
string in that redirect uri. You can use that <code>code</code> on your site backend along with your client
credentials (client id &amp; secret) to get an <em>Access Token</em> (AT) and <em>Refresh Token</em> (RT). You don't
send the AT (and never ever the RT!) to the browser but rather keep it on the server side and
associate it with that particular user session in order to be able to call Schibsted account APIs on
behalf of that user.</p>
<p><a name="events"></a></p>
<h2>Events</h2>
<p>The SDK fires events when something we deem interesting is happening. For example the
<a href="https://schibsted.github.io/account-sdk-browser/Identity.html">Identity</a> class
emits some events when the user is logged in or logged out. This SDK uses a familar interface that's
very similar to Node's <a href="https://nodejs.org/api/events.html">EventEmitter</a>. The most important
methods are <code>.on(eventName, listener)</code> (to subscribe to an event) and <code>.off(eventName, listener)</code>
(to unsubscribe to an event).</p>
<p><a name="identity"></a></p>
<h2>Identity</h2>
<p>Let's start with a bit of example code:</p>
<h4>Example</h4>
<pre class="prettyprint source lang-javascript"><code>import { Identity } from '@schibsted/account-sdk-browser'

const identity = new Identity({
    clientId: '56e9a5d1eee0000000000000',
    redirectUri: 'https://awesomenews.site', // ensure it's listed in selfservice
    env: 'PRE', // Schibsted account env. A url or a special key: 'PRE', 'PRO' or 'PRO_NO'
})

async function whenSiteLoaded() {
    const loginContainer = document.getElementById('login-container')
    if (await identity.isLoggedIn()) {
        const user = await identity.getUser()
        const span = document.createElement('span')
        span.textContent = `Hello ${user.givenName}`
        loginContainer.appendChild(span)
    } else {
        loginContainer.innerHTML = '&lt;button class=&quot;login-button&quot;>Log in&lt;/button>'
    }
}

function userClicksLogIn() {
    identity.login({ state: 'some-random-string-1234-foobar-wonky-pig' })
}
</code></pre>
<p><a name="regarding-state"></a></p>
<h4>Regarding <code>state</code></h4>
<p>This parameter is an OpenID Connect parameter (described in <a href="http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1">this paragraph in the
spec</a>). It's formatted as
an opaque string. This means you can send anything that can be serialized to a string. In practice,
we have good experience sending something like a JSON value like a base64-url-encoded value — it's
just an easy way to avoid browsers or backends messing with special characters.</p>
<p>But as a trivial example, if you call <code>Identity.login(..)</code> with params
<code>redirectUri=https://site.com&amp;state=article%3D1234</code> — then at the end of the authentication flow,
the user will be sent back to your redirectUri, and the <code>state</code> parameter will be forwarded along
with the auth <code>code</code> parameter.</p>
<p>It is recommended that you provide a unique identifier as part of the state, to prevent CSRF
attacks. For example this can be accomplished by:</p>
<ol>
<li>Your backend generates random token: <code>1234abcd</code>, saves it in some tokenCache, and forwards to
your browser frontend</li>
<li>Your frontend calls <code>Identity.login</code> with <code>state = base64Urlencode({ token: '1234abcd', article: '1234', ... })</code></li>
<li>When auth flow completes, the user is redirected back to your site. Then, your backend sees the
query parameters <code>code</code> (which it can exchange for OAuth tokens for the user) and <code>state</code></li>
<li>Your backend can do <code>decodedState = base64Urldecode(query.state)</code> and then verify that its
<code>tokenCache.contains(decodedState.token)</code>. If that fails, then possibly a CSRF attack was
attempted. If successful, remove the token from the tokenCache so the same token can't be used
again, and continue to show <code>decodedState.article</code></li>
</ol>
<p><a name="authentication-methods"></a></p>
<h4>Authentication methods</h4>
<p>Although Schibsted account abstracts away the details of how the users sign up or log in, it's worth
mentioning that your end users have a few ways to log in:</p>
<ul>
<li>Username &amp; password: pretty self-explanatory; users register using an email address and a
self-chosen password</li>
<li>Passwordless - email: here, the users enter their email address and receive a one-time code that
they can use to log in</li>
<li>Passwordless - SMS (BETA): similar to the previous method but instead of an email address, they receive
the code on their phone as an SMS</li>
</ul>
<p>IMPORTANT: Passwordless using SMS is still in BETA. It's only recommended to use it for testing and
experimental purposes for now. Please let us know before using this in production.</p>
<p>The default is username &amp; password. If you wish to use one of the passwordless login methods, the
<code>login()</code> function takes an optional parameter called <code>acrValues</code> (yeah, it's an OAuth specific
name). Please set this parameter to either <code>otp-email</code> or <code>otp-sms</code>.</p>
<p>The classic way to authenticate a user, is to send them from your site to the Schibsted account
domain, let the user authenticate there, and then have us redirect them back to your site. If you
prefer, we also provide a popup that you can use. In this method, the authentication happens on a
separate popup window and at the end of the auth flow. We recommend that you make the popup send a
signal to your main page — using
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage</a> or something
similar — to indicate that the user is logged in. If the popup window fails to open, it'll
automatically fall back to the redirect flow. The SDK Example project mentioned above demonstrates
how it can work. Again, you can see <a href="https://github.com/schibsted/sdk-example">sdk-example</a> if you
want a working example.</p>
<p><a name="is-the-user-logged-in"></a></p>
<h4>Is the user logged in?</h4>
<p>Schibsted account relies on browser cookies to determine whether a user is recognized as logged in.
The SDK provides functions that can be used to check if the user that's visiting your site is
already a Schibsted user or not.</p>
<ul>
<li><a href="https://schibsted.github.io/account-sdk-browser/Identity.html#isLoggedIn">Identity#isLoggedIn</a>
tells you if the user that is visiting your site is already logged in to Schibsted account or not.</li>
<li><a href="https://schibsted.github.io/account-sdk-browser/Identity.html#isConnected">Identity#isConnected</a>
tells you if the user is connected to your client. A user might have <code>isLoggedIn=true</code> and at the
same time <code>isConnected=false</code> if they have logged in to Schibsted account, but not accepted terms
and privacy policy for your site.</li>
</ul>
<p>If you've lately changed your terms &amp; conditions, maybe the user still hasn't accepted them. In that
case they are considered <em>not connected</em>. In that case, if they click &quot;Log in&quot; from your site, we
will just ask them to accept those terms and redirect them right back to your site.</p>
<p><a name="logging-out"></a></p>
<h4>Logging out</h4>
<p>If you want to log the user out of Schibsted account, you can call
<a href="https://schibsted.github.io/account-sdk-browser/Identity.html#logout">Identity#logout</a>. This
will remove the Schibsted account browser session, and so log the user out of all Schibsted sites in
that browser.</p>
<p>On your site backend, it may or may not make sense to remove the access/refresh tokens that you got
from Schibsted account. This can simply be achieved by removing it from your session or just
deleting the session. At this time, there are no ways to invalidate the tokens so they will not be
usable. <em>In the future you might be able to invalidate tokens. This comes in handy if you know that
a token is compromised and you don't want them to be usable in the future.</em></p>
<p><a name="monetization"></a></p>
<h2>Monetization</h2>
<p>The preferred method for checking whether a user has access to a product/subscription is
<a href="https://schibsted.github.io/account-sdk-browser/Monetization.html#hasAccess">Monetization#hasAccess</a>.
It requires using session-service, and supports both Schibsted account productId's and Zuora
feature id's.</p>
<h4>Example</h4>
<pre class="prettyprint source lang-javascript"><code>import { Monetization } from '@schibsted/account-sdk-browser'

const monetization = new Monetization({
    clientId: '56e9a5d1eee0000000000000',
    redirectUri: 'https://awesomenews.site', // ensure it's listed in selfservice
    sessionDomain: 'https://id.aweseome.site', // client-configured session-service domain
    env: 'PRE', // Schibsted account env. A url or a special key: 'PRE', 'PRO' or 'PRO_NO'
});

try {
    // Check if the user has access to a a particular product
    const userId = await identity.getUserId();
    const data = await monetization.hasAccess([productId], userId);
    alert(`User has access to ${productId}? ${data.entitled}`)
} catch (err) {
    alert(`Could not query if the user has access to ${productId} because ${err}`)
}
</code></pre>
<h3>Legacy methods</h3>
<ul>
<li><a href="https://schibsted.github.io/account-sdk-browser/Monetization.html#hasProduct">Monetization#hasProduct</a>
for checking if the user has access to a particular product</li>
<li><a href="https://schibsted.github.io/account-sdk-browser/Monetization.html#hasSubscription">Monetization#hasSubscription</a>
for checking if the user has access to a particular subscription</li>
</ul>
<p>These two functions require a parameter <code>sp_id</code> that is obtained from
<a href="https://schibsted.github.io/account-sdk-browser/Identity.html#getSpId">Identity#getSpId</a>
asynchronously.</p>
<h4>Example</h4>
<pre class="prettyprint source lang-javascript"><code>import { Monetization } from '@schibsted/account-sdk-browser'

const monetization = new Monetization({
    clientId: '56e9a5d1eee0000000000000',
    redirectUri: 'https://awesomenews.site', // ensure it's listed in selfservice
    env: 'PRE', // Schibsted account env. A url or a special key: 'PRE', 'PRO' or 'PRO_NO'
})

try {
    // Check if the user has access to a a particular product
    // You need the sp_id parameter that is obtained from an Identity instance
    const sp_id = await identity.getSpId()
    const data = await monetization.hasProduct(productId, sp_id)
    alert(`User has access to ${productId}? ${data.result}`)
} catch (err) {
    alert(`Could not query if the user has access to ${productId} because ${err}`)
}
</code></pre>
<p><a name="payment"></a></p>
<h2>Payment</h2>
<p>This class provides methods for paying with a so-called paylink, buying a product, getting links to
pages for redeeming voucher codes, reviewing payment history, and more.</p>
<h4>Example</h4>
<pre class="prettyprint source lang-javascript"><code>import { Payment } from '@schibsted/account-sdk-browser'

const paymentSDK = new Payment({
    clientId: '56e9a5d1eee0000000000000',
    redirectUri: 'https://awesomenews.site', // ensure it's listed in selfservice
    env: 'PRE', // Schibsted account env. A url or a special key: 'PRE', 'PRO' or 'PRO_NO'
})

// Get the url to paymentSDK with paylink
const paylink = '...'
const paylinkUrl = paymentSDK.purchasePaylinkUrl(paylink)

// Or another example --- pay with paylink in a popup
paymentSDK.payWithPaylink(paylink)
</code></pre>
<p><a name="appendix"></a></p>
<h2>Appendix</h2>
<h4>Cookies</h4>
<p>There are some cookies used by Schibsted account. They should all be considered opaque on the
browser side. Nevertheless, here is a short description of them.</p>
<ol>
<li>The <strong>autologin</strong> cookie (often called 'the remember-me-cookie'): The cookie name in the
production environments is <code>vgs_email</code>, because reasons (on PRE, it is called <code>spid-pre-data</code>).
It's a JSON string that's encoded using the standard <code>encodeURIComponent()</code> function and is an
object that contains two pieces of information that's important:
<ul>
<li><code>remember</code>: if set to <code>true</code>, the user chose to be remembered and this means we usually support
auto-login (that is, if you call the Schibsted account hassession service, and no session can
be found in the session database, it will automatically create a new one for the user so that
they don't have to authenticate again. If it is <code>false</code>, it should be interpreted as the user
does not want to be automatically logged in to any site when their session expires</li>
<li><code>v</code>: the version number</li>
</ul>
</li>
<li>The <strong>session</strong> cookies: Cookie names in production environments are <code>identity</code>, and <code>SPID_SE</code> or
<code>SPID_NO</code>. It contains:
<ul>
<li><code>user</code>: an object (if it's missing, a call to hassession will return a <code>401</code> with a
<code>UserException</code> that says <code>No session found</code>)
<ul>
<li><code>userId</code> identifies the user. We use this property to compare &quot;old&quot; user with &quot;new&quot; user and
fire events that indicate that the user has changed</li>
<li><code>is_logged_in</code> indicates if the user is logged in</li>
</ul>
</li>
<li><code>user_tags</code>: a map that contains some flags about the user; namely:
<ul>
<li><code>is_logged_in</code> indicates if the user is logged in (this seems to be a duplicate of a
property with a similar name in the parent <code>user</code> object)</li>
<li><code>terms</code>: a map of term ids that indicate if they've been accepted by the user.</li>
</ul>
</li>
<li><code>referer</code> (yep, missing the double &quot;rr&quot;..): If this is missing, a call to hassession will
return a <code>401</code> with a <code>UserException</code> that says <code>No session found</code>.</li>
</ul>
</li>
</ol>
<h2>LICENSE</h2>
<p>Copyright (c) 2018 Schibsted Products &amp; Technology AS</p>
<p>Licensed under the <a href="https://github.com/schibsted/account-sdk-browser/blob/master/LICENSE.md">MIT
License</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.</p></article>
    </section>






</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Mon Apr 27 2020 12:10:59 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>